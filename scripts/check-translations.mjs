#!/usr/bin/env node
/**
 * check-translations.mjs
 *
 * Compares all language JSON files against en.json (the source of truth).
 * Writes src/components/i18n/TRANSLATION_STATUS.md with a completion
 * percentage table and list of missing keys per language.
 *
 * Usage:  node scripts/check-translations.mjs
 */

import { readFileSync, writeFileSync, readdirSync } from "fs";
import { resolve, dirname } from "path";
import { fileURLToPath } from "url";

const __dirname = dirname(fileURLToPath(import.meta.url));
const I18N_DIR = resolve(__dirname, "../src/components/i18n");

// â”€â”€ helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/** Recursively flatten nested object keys into dot-notation strings. */
function flattenKeys(obj, prefix = "") {
  return Object.entries(obj).flatMap(([key, value]) => {
    if (key.startsWith("_")) return []; // ignore meta keys like _missing
    const full = prefix ? `${prefix}.${key}` : key;
    return typeof value === "object" && value !== null
      ? flattenKeys(value, full)
      : [full];
  });
}

/** Recursively check whether a dot-notation key exists in a nested object. */
function hasKey(obj, dotKey) {
  const parts = dotKey.split(".");
  let cur = obj;
  for (const part of parts) {
    if (cur == null || typeof cur !== "object" || !(part in cur)) return false;
    cur = cur[part];
  }
  return typeof cur === "string";
}

/** Read and parse a JSON file. */
function readJson(path) {
  return JSON.parse(readFileSync(path, "utf8"));
}

// â”€â”€ main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const files = readdirSync(I18N_DIR).filter((f) => f.endsWith(".json"));
const langFiles = files.filter((f) => f !== "en.json");

const enData = readJson(resolve(I18N_DIR, "en.json"));
const enKeys = flattenKeys(enData);

console.log(`English keys: ${enKeys.length}`);

const results = [];

for (const file of langFiles) {
  const lang = file.replace(".json", "");
  const data = readJson(resolve(I18N_DIR, file));

  const missing = enKeys.filter((k) => !hasKey(data, k));
  const present = enKeys.length - missing.length;
  const pct = Math.round((present / enKeys.length) * 100);

  const label = missing.length > 0 ? `${missing.length} missing key(s)` : "complete âœ“";
  console.log(`${file}: ${present}/${enKeys.length} (${pct}%) â€” ${label}`);

  results.push({ lang, present, total: enKeys.length, pct, missing });
}

// â”€â”€ write TRANSLATION_STATUS.md â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const rows = results
  .sort((a, b) => b.pct - a.pct)
  .map(({ lang, present, total, pct, missing }) => {
    const bar = buildBar(pct);
    const status = pct === 100 ? "âœ…" : pct >= 80 ? "ðŸŸ¡" : "ðŸ”´";
    return `| ${lang} | ${present} / ${total} | ${pct}% ${bar} | ${status} |`;
  });

const missingDetails = results
  .filter((r) => r.missing.length > 0)
  .sort((a, b) => b.pct - a.pct)
  .map(({ lang, missing }) => {
    const keys = missing.map((k) => `  - \`${k}\``).join("\n");
    return `### ${lang}\n\n${keys}`;
  })
  .join("\n\n");

function buildBar(pct) {
  const filled = Math.round(pct / 10);
  return "â–ˆ".repeat(filled) + "â–‘".repeat(10 - filled);
}

const now = new Date().toISOString().split("T")[0];
const md = `# Translation Status

> Auto-generated by \`scripts/check-translations.mjs\` â€” last run ${now}

## Summary

| Language | Keys translated | Completion | Status |
|----------|----------------|------------|--------|
${rows.join("\n")}

_Total English keys: ${enKeys.length}_

## Missing keys per language

${missingDetails || "_All languages are complete!_"}
`;

const mdPath = resolve(I18N_DIR, "TRANSLATION_STATUS.md");
writeFileSync(mdPath, md, "utf8");
console.log(`\nWrote ${mdPath}`);
